//Generated by Enki v1.2

/+
    Copyright (c) 2006 Eric Anderton

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
+/

module enki.EnkiParser;
version(build) pragma(export_version,EnkiUTF8);

debug private import tango.io.Stdout;
private import enki.types;
private import enki.EnkiBackend;
private import enki.Rule;
private import enki.Expression;
private import enki.Directive;



class EnkiParser : BaseEnkiParser{

	/*
	
WS
	::=  ws [ (  SlashSlashComment |  SlashStarComment)  WS];

	*/
	public ResultT!(bool) parse_WS(){
		debug Stdout.formatln("parse_WS()");
		uint start1 = position;
		//no declarations
		
		
		{//Expression
			uint start2 = position;
			if(!(parse_ws().success)){
				goto mismatch4;
			}
			{//OptionalExpr
				{//Expression
					uint start4 = position;
					{//Expression
						uint start5 = position;
						if((parse_SlashSlashComment().success) || (parse_SlashStarComment().success)){
							clearErrors();
						}else{
							setError("Expected SlashSlashComment or SlashStarComment.");
							position = start5;
							goto mismatch6;
						}
					}
					if(!(parse_WS().success)){
						goto mismatch6;
					}
					goto match5;
				mismatch6:
					{/*do nothing*/}
					position = start4;
					{/*do nothing*/}
				match5:
					clearErrors();
					{/*do nothing*/}
				}
			}
			goto match3;
		mismatch4:
			setError("Expected ws.");
			position = start2;
			goto mismatch2;
		match3:
			clearErrors();
			goto match1;
		}
	match1:
		debug Stdout.formatln("parse_WS() PASS");
		return ResultT!(bool)(true);
	mismatch2:
		position = start1;
		return ResultT!(bool)();
	}

	/*
	
Syntax
	= void createSyntax(SyntaxLine[] lines)
	::=  WS { (  Rule:~lines |  Comment:~lines |  Directive:~lines)  WS} eoi;

	*/
	public ResultT!(String) parse_Syntax(){
		debug Stdout.formatln("parse_Syntax()");
		uint start6 = position;
		SyntaxLine[] bind_lines;
		
		
		{//Expression
			uint start7 = position;
			if(!(parse_WS().success)){
				goto mismatch10;
			}
			{//ZeroOrMoreExpr
				uint start8 = position;
				uint termPos9;
			loop11:
				termPos9 = position;
				if(parse_eoi().success){
					goto loopend12;
				}else{
					goto exprStart13;
				}
			exprStart13:
				{//Expression
					uint start10 = position;
					{//Expression
						uint start11 = position;
						if((parse_Rule().assignCat!(SyntaxLine[])(bind_lines)) || (parse_Comment().assignCat!(SyntaxLine[])(bind_lines)) || (parse_Directive().assignCat!(SyntaxLine[])(bind_lines))){
							clearErrors();
						}else{
							setError("Expected Rule, Comment or Directive.");
							position = start11;
							goto mismatch15;
						}
					}
					if(!(parse_WS().success)){
						goto mismatch15;
					}
					goto match14;
				mismatch15:
					{/*do nothing*/}
					position = start10;
					goto loopend12;
				match14:
					clearErrors();
					goto loop11;
				}
			loopend12:
				{/*do nothing*/}
			}
			goto match9;
		mismatch10:
			setError("Expected WS.");
			position = start7;
			goto mismatch8;
		match9:
			clearErrors();
			goto match7;
		}
	match7:
		debug Stdout.formatln("parse_Syntax() PASS");
		createSyntax(bind_lines);
		return ResultT!(String)(sliceData(start6,position));
	mismatch8:
		position = start6;
		return ResultT!(String)();
	}

	/*
	
Rule
	= new Rule(String name,RulePredicate pred,Expression expr,RuleDecl decl)
	::=  Identifier:name  WS [  RuleDecl:decl  WS] [  RulePredicate:pred]  WS  "::="  WS  Expression:expr  WS  ";";

	*/
	public ResultT!(Rule) parse_Rule(){
		debug Stdout.formatln("parse_Rule()");
		uint start12 = position;
		String bind_name;
		RulePredicate bind_pred;
		Expression bind_expr;
		RuleDecl bind_decl;
		
		
		{//Expression
			uint start13 = position;
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch19;
			}
			if(!(parse_WS().success)){
				goto mismatch19;
			}
			{//OptionalExpr
				{//Expression
					uint start15 = position;
					if((parse_RuleDecl().assign!(RuleDecl)(bind_decl) && parse_WS().success)){
						clearErrors();
					}else{
						position = start15;
					}
				}
			}
			{//OptionalExpr
				{//Expression
					uint start17 = position;
					if((parse_RulePredicate().assign!(RulePredicate)(bind_pred))){
						clearErrors();
					}else{
						position = start17;
					}
				}
			}
			if(!(parse_WS().success)){
				goto mismatch19;
			}
			if(!(terminal("::=").success)){
				goto mismatch19;
			}
			if(!(parse_WS().success)){
				goto mismatch19;
			}
			if(!(parse_Expression().assign!(Expression)(bind_expr))){
				goto mismatch19;
			}
			if(!(parse_WS().success)){
				goto mismatch19;
			}
			if(!(terminal(";").success)){
				goto mismatch19;
			}
			goto match18;
		mismatch19:
			setError("Expected Identifier.");
			position = start13;
			goto mismatch17;
		match18:
			clearErrors();
			goto match16;
		}
	match16:
		debug Stdout.formatln("parse_Rule() PASS");
		ResultT!(Rule) passed = ResultT!(Rule)(new Rule(bind_name,bind_pred,bind_expr,bind_decl));
		return passed;
	mismatch17:
		position = start12;
		ResultT!(Rule) failed = ResultT!(Rule)();
		return failed;
	}

	/*
	
RuleDecl
	= new RuleDecl(Param[] params)
	::=  ParamsExpr:params;

	*/
	public ResultT!(RuleDecl) parse_RuleDecl(){
		debug Stdout.formatln("parse_RuleDecl()");
		uint start18 = position;
		Param[] bind_params;
		
		
		{//Expression
			uint start19 = position;
			if((parse_ParamsExpr().assign!(Param[])(bind_params))){
				clearErrors();
				goto match20;
			}else{
				setError("Expected ParamsExpr.");
				position = start19;
				goto mismatch21;
			}
		}
	match20:
		debug Stdout.formatln("parse_RuleDecl() PASS");
		ResultT!(RuleDecl) passed = ResultT!(RuleDecl)(new RuleDecl(bind_params));
		return passed;
	mismatch21:
		position = start18;
		ResultT!(RuleDecl) failed = ResultT!(RuleDecl)();
		return failed;
	}

	/*
	
RulePredicate
	= RulePredicate pred
	::=  "="  WS (  ClassPredicate:pred |  FunctionPredicate:pred |  BindingPredicate:pred);

	*/
	public ResultT!(RulePredicate) parse_RulePredicate(){
		debug Stdout.formatln("parse_RulePredicate()");
		uint start20 = position;
		RulePredicate bind_pred;
		
		
		{//Expression
			uint start21 = position;
			if(!(terminal("=").success)){
				goto mismatch25;
			}
			if(!(parse_WS().success)){
				goto mismatch25;
			}
			{//Expression
				uint start22 = position;
				if((parse_ClassPredicate().assign!(RulePredicate)(bind_pred)) || (parse_FunctionPredicate().assign!(RulePredicate)(bind_pred)) || (parse_BindingPredicate().assign!(RulePredicate)(bind_pred))){
					clearErrors();
				}else{
					setError("Expected ClassPredicate, FunctionPredicate or BindingPredicate.");
					position = start22;
					goto mismatch25;
				}
			}
			goto match24;
		mismatch25:
			{/*do nothing*/}
			position = start21;
			goto mismatch23;
		match24:
			clearErrors();
			goto match22;
		}
	match22:
		debug Stdout.formatln("parse_RulePredicate() PASS");
		return ResultT!(RulePredicate)(bind_pred);
	mismatch23:
		position = start20;
		return ResultT!(RulePredicate)();
	}

	/*
	
ClassPredicate
	= new ClassPredicate(String name,Param[] params)
	::=  "new"  WS  Identifier:name  WS  ParamsExpr:params;

	*/
	public ResultT!(ClassPredicate) parse_ClassPredicate(){
		debug Stdout.formatln("parse_ClassPredicate()");
		uint start23 = position;
		String bind_name;
		Param[] bind_params;
		
		
		{//Expression
			uint start24 = position;
			if((terminal("new").success && parse_WS().success && parse_Identifier().assign!(String)(bind_name) && parse_WS().success && parse_ParamsExpr().assign!(Param[])(bind_params))){
				clearErrors();
				goto match26;
			}else{
				position = start24;
				goto mismatch27;
			}
		}
	match26:
		debug Stdout.formatln("parse_ClassPredicate() PASS");
		ResultT!(ClassPredicate) passed = ResultT!(ClassPredicate)(new ClassPredicate(bind_name,bind_params));
		return passed;
	mismatch27:
		position = start23;
		ResultT!(ClassPredicate) failed = ResultT!(ClassPredicate)();
		return failed;
	}

	/*
	
FunctionPredicate
	= new FunctionPredicate(Param decl,Param[] params)
	::=  ExplicitParam:decl  WS  ParamsExpr:params;

	*/
	public ResultT!(FunctionPredicate) parse_FunctionPredicate(){
		debug Stdout.formatln("parse_FunctionPredicate()");
		uint start25 = position;
		Param bind_decl;
		Param[] bind_params;
		
		
		{//Expression
			uint start26 = position;
			if((parse_ExplicitParam().assign!(Param)(bind_decl) && parse_WS().success && parse_ParamsExpr().assign!(Param[])(bind_params))){
				clearErrors();
				goto match28;
			}else{
				setError("Expected ExplicitParam.");
				position = start26;
				goto mismatch29;
			}
		}
	match28:
		debug Stdout.formatln("parse_FunctionPredicate() PASS");
		ResultT!(FunctionPredicate) passed = ResultT!(FunctionPredicate)(new FunctionPredicate(bind_decl,bind_params));
		return passed;
	mismatch29:
		position = start25;
		ResultT!(FunctionPredicate) failed = ResultT!(FunctionPredicate)();
		return failed;
	}

	/*
	
BindingPredicate
	= new BindingPredicate(Param param)
	::=  Param:param;

	*/
	public ResultT!(BindingPredicate) parse_BindingPredicate(){
		debug Stdout.formatln("parse_BindingPredicate()");
		uint start27 = position;
		Param bind_param;
		
		
		{//Expression
			uint start28 = position;
			if((parse_Param().assign!(Param)(bind_param))){
				clearErrors();
				goto match30;
			}else{
				setError("Expected Param.");
				position = start28;
				goto mismatch31;
			}
		}
	match30:
		debug Stdout.formatln("parse_BindingPredicate() PASS");
		ResultT!(BindingPredicate) passed = ResultT!(BindingPredicate)(new BindingPredicate(bind_param));
		return passed;
	mismatch31:
		position = start27;
		ResultT!(BindingPredicate) failed = ResultT!(BindingPredicate)();
		return failed;
	}

	/*
	
ParamsExpr
	= Param[] params
	::=  "("  WS [  Param:~params  WS {  ","  WS  Param:~params  WS}]  ")";

	*/
	public ResultT!(Param[]) parse_ParamsExpr(){
		debug Stdout.formatln("parse_ParamsExpr()");
		uint start29 = position;
		Param[] bind_params;
		
		
		{//Expression
			uint start30 = position;
			if(!(terminal("(").success)){
				goto mismatch35;
			}
			if(!(parse_WS().success)){
				goto mismatch35;
			}
			{//OptionalExpr
				{//Expression
					uint start32 = position;
					if(!(parse_Param().assignCat!(Param[])(bind_params))){
						goto mismatch37;
					}
					if(!(parse_WS().success)){
						goto mismatch37;
					}
					{//ZeroOrMoreExpr
						uint termPos34;
					loop38:
						termPos34 = position;
					exprStart40:
						{//Expression
							uint start35 = position;
							if((terminal(",").success && parse_WS().success && parse_Param().assignCat!(Param[])(bind_params) && parse_WS().success)){
								clearErrors();
								goto loop38;
							}else{
								position = start35;
								goto loopend39;
							}
						}
					loopend39:
						{/*do nothing*/}
					}
					goto match36;
				mismatch37:
					{/*do nothing*/}
					position = start32;
					{/*do nothing*/}
				match36:
					clearErrors();
					{/*do nothing*/}
				}
			}
			if(!(terminal(")").success)){
				goto mismatch35;
			}
			goto match34;
		mismatch35:
			{/*do nothing*/}
			position = start30;
			goto mismatch33;
		match34:
			clearErrors();
			goto match32;
		}
	match32:
		debug Stdout.formatln("parse_ParamsExpr() PASS");
		return ResultT!(Param[])(bind_params);
	mismatch33:
		position = start29;
		return ResultT!(Param[])();
	}

	/*
	
Param
	= Param param
	::=  ExplicitParam:param |  WeakParam:param;

	*/
	public ResultT!(Param) parse_Param(){
		debug Stdout.formatln("parse_Param()");
		uint start36 = position;
		Param bind_param;
		
		
		{//Expression
			uint start37 = position;
			if((parse_ExplicitParam().assign!(Param)(bind_param)) || (parse_WeakParam().assign!(Param)(bind_param))){
				clearErrors();
				goto match41;
			}else{
				setError("Expected ExplicitParam or WeakParam.");
				position = start37;
				goto mismatch42;
			}
		}
	match41:
		debug Stdout.formatln("parse_Param() PASS");
		return ResultT!(Param)(bind_param);
	mismatch42:
		position = start36;
		return ResultT!(Param)();
	}

	/*
	
WeakParam
	= new Param(String name)
	::=  Identifier:name;

	*/
	public ResultT!(Param) parse_WeakParam(){
		debug Stdout.formatln("parse_WeakParam()");
		uint start38 = position;
		String bind_name;
		
		
		{//Expression
			uint start39 = position;
			if((parse_Identifier().assign!(String)(bind_name))){
				clearErrors();
				goto match43;
			}else{
				setError("Expected Identifier.");
				position = start39;
				goto mismatch44;
			}
		}
	match43:
		debug Stdout.formatln("parse_WeakParam() PASS");
		ResultT!(Param) passed = ResultT!(Param)(new Param(bind_name));
		return passed;
	mismatch44:
		position = start38;
		ResultT!(Param) failed = ResultT!(Param)();
		return failed;
	}

	/*
	
ExplicitParam
	= new Param(bool isArray,String type,String name)
	::=  Identifier:type  WS [  "[]":isArray  Brackets  WS]  Identifier:name;

	*/
	public ResultT!(Param) parse_ExplicitParam(){
		debug Stdout.formatln("parse_ExplicitParam()");
		uint start40 = position;
		bool bind_isArray;
		String bind_type;
		String bind_name;
		
		
		{//Expression
			uint start41 = position;
			if(!(parse_Identifier().assign!(String)(bind_type))){
				goto mismatch48;
			}
			if(!(parse_WS().success)){
				goto mismatch48;
			}
			{//OptionalExpr
				{//Expression
					uint start43 = position;
					if((terminal("[]").assign!(bool)(bind_isArray) && parse_Brackets().success && parse_WS().success)){
						clearErrors();
					}else{
						position = start43;
					}
				}
			}
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch48;
			}
			goto match47;
		mismatch48:
			setError("Expected Identifier.");
			position = start41;
			goto mismatch46;
		match47:
			clearErrors();
			goto match45;
		}
	match45:
		debug Stdout.formatln("parse_ExplicitParam() PASS");
		ResultT!(Param) passed = ResultT!(Param)(new Param(bind_isArray,bind_type,bind_name));
		return passed;
	mismatch46:
		position = start40;
		ResultT!(Param) failed = ResultT!(Param)();
		return failed;
	}

	/*
	
Brackets
	::= [  "[]"  Brackets];

	*/
	public ResultT!(bool) parse_Brackets(){
		debug Stdout.formatln("parse_Brackets()");
		uint start44 = position;
		//no declarations
		
		
		{//Expression
			uint start45 = position;
			{//OptionalExpr
				{//Expression
					uint start47 = position;
					if((terminal("[]").success && parse_Brackets().success)){
						clearErrors();
					}else{
						position = start47;
					}
				}
			}
			goto match51;
		mismatch52:
			{/*do nothing*/}
			position = start45;
			goto mismatch50;
		match51:
			clearErrors();
			goto match49;
		}
	match49:
		debug Stdout.formatln("parse_Brackets() PASS");
		return ResultT!(bool)(true);
	mismatch50:
		position = start44;
		return ResultT!(bool)();
	}

	/*
	
Expression
	= new Expression(Term[] terms)
	::=  Term:~terms  WS {  "|"  WS  Term:~terms  WS};

	*/
	public ResultT!(Expression) parse_Expression(){
		debug Stdout.formatln("parse_Expression()");
		uint start48 = position;
		Term[] bind_terms;
		
		
		{//Expression
			uint start49 = position;
			if(!(parse_Term().assignCat!(Term[])(bind_terms))){
				goto mismatch56;
			}
			if(!(parse_WS().success)){
				goto mismatch56;
			}
			{//ZeroOrMoreExpr
				uint termPos51;
			loop57:
				termPos51 = position;
			exprStart59:
				{//Expression
					uint start52 = position;
					if((terminal("|").success && parse_WS().success && parse_Term().assignCat!(Term[])(bind_terms) && parse_WS().success)){
						clearErrors();
						goto loop57;
					}else{
						position = start52;
						goto loopend58;
					}
				}
			loopend58:
				{/*do nothing*/}
			}
			goto match55;
		mismatch56:
			setError("Expected Term.");
			position = start49;
			goto mismatch54;
		match55:
			clearErrors();
			goto match53;
		}
	match53:
		debug Stdout.formatln("parse_Expression() PASS");
		ResultT!(Expression) passed = ResultT!(Expression)(new Expression(bind_terms));
		return passed;
	mismatch54:
		position = start48;
		ResultT!(Expression) failed = ResultT!(Expression)();
		return failed;
	}

	/*
	
Term
	= SubExpression[] factors
	::=  SubExpression:~factors  WS {  SubExpression:~factors  WS};

	*/
	public ResultT!(SubExpression[]) parse_Term(){
		debug Stdout.formatln("parse_Term()");
		uint start53 = position;
		SubExpression[] bind_factors;
		
		
		{//Expression
			uint start54 = position;
			if(!(parse_SubExpression().assignCat!(SubExpression[])(bind_factors))){
				goto mismatch63;
			}
			if(!(parse_WS().success)){
				goto mismatch63;
			}
			{//ZeroOrMoreExpr
				uint termPos56;
			loop64:
				termPos56 = position;
			exprStart66:
				{//Expression
					uint start57 = position;
					if((parse_SubExpression().assignCat!(SubExpression[])(bind_factors) && parse_WS().success)){
						clearErrors();
						goto loop64;
					}else{
						setError("Expected SubExpression.");
						position = start57;
						goto loopend65;
					}
				}
			loopend65:
				{/*do nothing*/}
			}
			goto match62;
		mismatch63:
			setError("Expected SubExpression.");
			position = start54;
			goto mismatch61;
		match62:
			clearErrors();
			goto match60;
		}
	match60:
		debug Stdout.formatln("parse_Term() PASS");
		return ResultT!(SubExpression[])(bind_factors);
	mismatch61:
		position = start53;
		return ResultT!(SubExpression[])();
	}

	/*
	
SubExpression
	= SubExpression expr
	::=  Production:expr |  Substitution:expr |  Terminal:expr |  Range:expr |  Regexp:expr |  GroupExpr:expr |  OptionalExpr:expr |  ZeroOrMoreExpr:expr |  NegateExpr:expr |  TestExpr:expr |  LiteralExpr:expr |  CustomTerminal:expr;

	*/
	public ResultT!(SubExpression) parse_SubExpression(){
		debug Stdout.formatln("parse_SubExpression()");
		uint start58 = position;
		SubExpression bind_expr;
		
		
		{//Expression
			uint start59 = position;
			if((parse_Production().assign!(SubExpression)(bind_expr)) || (parse_Substitution().assign!(SubExpression)(bind_expr)) || (parse_Terminal().assign!(SubExpression)(bind_expr)) || (parse_Range().assign!(SubExpression)(bind_expr)) || (parse_Regexp().assign!(SubExpression)(bind_expr)) || (parse_GroupExpr().assign!(SubExpression)(bind_expr)) || (parse_OptionalExpr().assign!(SubExpression)(bind_expr)) || (parse_ZeroOrMoreExpr().assign!(SubExpression)(bind_expr)) || (parse_NegateExpr().assign!(SubExpression)(bind_expr)) || (parse_TestExpr().assign!(SubExpression)(bind_expr)) || (parse_LiteralExpr().assign!(SubExpression)(bind_expr)) || (parse_CustomTerminal().assign!(SubExpression)(bind_expr))){
				clearErrors();
				goto match67;
			}else{
				setError("Expected Production, Substitution, Terminal, Range, Regexp, GroupExpr, OptionalExpr, ZeroOrMoreExpr, NegateExpr, TestExpr, LiteralExpr or CustomTerminal.");
				position = start59;
				goto mismatch68;
			}
		}
	match67:
		debug Stdout.formatln("parse_SubExpression() PASS");
		return ResultT!(SubExpression)(bind_expr);
	mismatch68:
		position = start58;
		return ResultT!(SubExpression)();
	}

	/*
	
Production
	= new Production(String name,Binding binding,ProductionArg[] args)
	::=  Identifier:name  WS [  "!("  WS  ProductionArg:~args {  WS  ","  WS  ProductionArg:~args} ")"] [  Binding:binding];

	*/
	public ResultT!(Production) parse_Production(){
		debug Stdout.formatln("parse_Production()");
		uint start60 = position;
		String bind_name;
		Binding bind_binding;
		ProductionArg[] bind_args;
		
		
		{//Expression
			uint start61 = position;
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch72;
			}
			if(!(parse_WS().success)){
				goto mismatch72;
			}
			{//OptionalExpr
				{//Expression
					uint start63 = position;
					if(!(terminal("!(").success)){
						goto mismatch74;
					}
					if(!(parse_WS().success)){
						goto mismatch74;
					}
					if(!(parse_ProductionArg().assignCat!(ProductionArg[])(bind_args))){
						goto mismatch74;
					}
					{//ZeroOrMoreExpr
						uint start64 = position;
						uint termPos65;
					loop75:
						termPos65 = position;
						if(terminal(")").success){
							goto loopend76;
						}else{
							goto exprStart77;
						}
					exprStart77:
						{//Expression
							uint start66 = position;
							if((parse_WS().success && terminal(",").success && parse_WS().success && parse_ProductionArg().assignCat!(ProductionArg[])(bind_args))){
								clearErrors();
								goto loop75;
							}else{
								setError("Expected WS.");
								position = start66;
								goto loopend76;
							}
						}
					loopend76:
						{/*do nothing*/}
					}
					goto match73;
				mismatch74:
					{/*do nothing*/}
					position = start63;
					{/*do nothing*/}
				match73:
					clearErrors();
					{/*do nothing*/}
				}
			}
			{//OptionalExpr
				{//Expression
					uint start68 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start68;
					}
				}
			}
			goto match71;
		mismatch72:
			setError("Expected Identifier.");
			position = start61;
			goto mismatch70;
		match71:
			clearErrors();
			goto match69;
		}
	match69:
		debug Stdout.formatln("parse_Production() PASS");
		ResultT!(Production) passed = ResultT!(Production)(new Production(bind_name,bind_binding,bind_args));
		return passed;
	mismatch70:
		position = start60;
		ResultT!(Production) failed = ResultT!(Production)();
		return failed;
	}

	/*
	
ProductionArg
	= ProductionArg arg
	::=  StringProductionArg:arg |  BindingProductionArg:arg;

	*/
	public ResultT!(ProductionArg) parse_ProductionArg(){
		debug Stdout.formatln("parse_ProductionArg()");
		uint start69 = position;
		ProductionArg bind_arg;
		
		
		{//Expression
			uint start70 = position;
			if((parse_StringProductionArg().assign!(ProductionArg)(bind_arg)) || (parse_BindingProductionArg().assign!(ProductionArg)(bind_arg))){
				clearErrors();
				goto match78;
			}else{
				setError("Expected StringProductionArg or BindingProductionArg.");
				position = start70;
				goto mismatch79;
			}
		}
	match78:
		debug Stdout.formatln("parse_ProductionArg() PASS");
		return ResultT!(ProductionArg)(bind_arg);
	mismatch79:
		position = start69;
		return ResultT!(ProductionArg)();
	}

	/*
	
StringProductionArg
	= new StringProductionArg(String value)
	::=  String:value;

	*/
	public ResultT!(StringProductionArg) parse_StringProductionArg(){
		debug Stdout.formatln("parse_StringProductionArg()");
		uint start71 = position;
		String bind_value;
		
		
		{//Expression
			uint start72 = position;
			if((parse_String().assign!(String)(bind_value))){
				clearErrors();
				goto match80;
			}else{
				setError("Expected String.");
				position = start72;
				goto mismatch81;
			}
		}
	match80:
		debug Stdout.formatln("parse_StringProductionArg() PASS");
		ResultT!(StringProductionArg) passed = ResultT!(StringProductionArg)(new StringProductionArg(bind_value));
		return passed;
	mismatch81:
		position = start71;
		ResultT!(StringProductionArg) failed = ResultT!(StringProductionArg)();
		return failed;
	}

	/*
	
BindingProductionArg
	= new BindingProductionArg(String value)
	::=  Identifier:value;

	*/
	public ResultT!(BindingProductionArg) parse_BindingProductionArg(){
		debug Stdout.formatln("parse_BindingProductionArg()");
		uint start73 = position;
		String bind_value;
		
		
		{//Expression
			uint start74 = position;
			if((parse_Identifier().assign!(String)(bind_value))){
				clearErrors();
				goto match82;
			}else{
				setError("Expected Identifier.");
				position = start74;
				goto mismatch83;
			}
		}
	match82:
		debug Stdout.formatln("parse_BindingProductionArg() PASS");
		ResultT!(BindingProductionArg) passed = ResultT!(BindingProductionArg)(new BindingProductionArg(bind_value));
		return passed;
	mismatch83:
		position = start73;
		ResultT!(BindingProductionArg) failed = ResultT!(BindingProductionArg)();
		return failed;
	}

	/*
	
Substitution
	= new Substitution(String name,Binding binding)
	::=  "."  Identifier:name  WS [  Binding:binding];

	*/
	public ResultT!(Substitution) parse_Substitution(){
		debug Stdout.formatln("parse_Substitution()");
		uint start75 = position;
		String bind_name;
		Binding bind_binding;
		
		
		{//Expression
			uint start76 = position;
			if(!(terminal(".").success)){
				goto mismatch87;
			}
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch87;
			}
			if(!(parse_WS().success)){
				goto mismatch87;
			}
			{//OptionalExpr
				{//Expression
					uint start78 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start78;
					}
				}
			}
			goto match86;
		mismatch87:
			{/*do nothing*/}
			position = start76;
			goto mismatch85;
		match86:
			clearErrors();
			goto match84;
		}
	match84:
		debug Stdout.formatln("parse_Substitution() PASS");
		ResultT!(Substitution) passed = ResultT!(Substitution)(new Substitution(bind_name,bind_binding));
		return passed;
	mismatch85:
		position = start75;
		ResultT!(Substitution) failed = ResultT!(Substitution)();
		return failed;
	}

	/*
	
GroupExpr
	= new GroupExpr(Expression expr,Binding binding)
	::=  "("  WS  Expression:expr  WS  ")"  WS [  Binding:binding];

	*/
	public ResultT!(GroupExpr) parse_GroupExpr(){
		debug Stdout.formatln("parse_GroupExpr()");
		uint start79 = position;
		Expression bind_expr;
		Binding bind_binding;
		
		
		{//Expression
			uint start80 = position;
			if(!(terminal("(").success)){
				goto mismatch91;
			}
			if(!(parse_WS().success)){
				goto mismatch91;
			}
			if(!(parse_Expression().assign!(Expression)(bind_expr))){
				goto mismatch91;
			}
			if(!(parse_WS().success)){
				goto mismatch91;
			}
			if(!(terminal(")").success)){
				goto mismatch91;
			}
			if(!(parse_WS().success)){
				goto mismatch91;
			}
			{//OptionalExpr
				{//Expression
					uint start82 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start82;
					}
				}
			}
			goto match90;
		mismatch91:
			{/*do nothing*/}
			position = start80;
			goto mismatch89;
		match90:
			clearErrors();
			goto match88;
		}
	match88:
		debug Stdout.formatln("parse_GroupExpr() PASS");
		ResultT!(GroupExpr) passed = ResultT!(GroupExpr)(new GroupExpr(bind_expr,bind_binding));
		return passed;
	mismatch89:
		position = start79;
		ResultT!(GroupExpr) failed = ResultT!(GroupExpr)();
		return failed;
	}

	/*
	
OptionalExpr
	= new OptionalExpr(Expression expr,Binding binding)
	::=  "["  WS  Expression:expr  WS  "]"  WS [  Binding:binding];

	*/
	public ResultT!(OptionalExpr) parse_OptionalExpr(){
		debug Stdout.formatln("parse_OptionalExpr()");
		uint start83 = position;
		Expression bind_expr;
		Binding bind_binding;
		
		
		{//Expression
			uint start84 = position;
			if(!(terminal("[").success)){
				goto mismatch95;
			}
			if(!(parse_WS().success)){
				goto mismatch95;
			}
			if(!(parse_Expression().assign!(Expression)(bind_expr))){
				goto mismatch95;
			}
			if(!(parse_WS().success)){
				goto mismatch95;
			}
			if(!(terminal("]").success)){
				goto mismatch95;
			}
			if(!(parse_WS().success)){
				goto mismatch95;
			}
			{//OptionalExpr
				{//Expression
					uint start86 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start86;
					}
				}
			}
			goto match94;
		mismatch95:
			{/*do nothing*/}
			position = start84;
			goto mismatch93;
		match94:
			clearErrors();
			goto match92;
		}
	match92:
		debug Stdout.formatln("parse_OptionalExpr() PASS");
		ResultT!(OptionalExpr) passed = ResultT!(OptionalExpr)(new OptionalExpr(bind_expr,bind_binding));
		return passed;
	mismatch93:
		position = start83;
		ResultT!(OptionalExpr) failed = ResultT!(OptionalExpr)();
		return failed;
	}

	/*
	
ZeroOrMoreExpr
	= new ZeroOrMoreExpr(Expression expr,Binding binding,SubExpression term)
	::=  "{"  WS  Expression:expr  WS  "}"  WS [  Binding:binding  WS] [  SubExpression:term];

	*/
	public ResultT!(ZeroOrMoreExpr) parse_ZeroOrMoreExpr(){
		debug Stdout.formatln("parse_ZeroOrMoreExpr()");
		uint start87 = position;
		Expression bind_expr;
		Binding bind_binding;
		SubExpression bind_term;
		
		
		{//Expression
			uint start88 = position;
			if(!(terminal("{").success)){
				goto mismatch99;
			}
			if(!(parse_WS().success)){
				goto mismatch99;
			}
			if(!(parse_Expression().assign!(Expression)(bind_expr))){
				goto mismatch99;
			}
			if(!(parse_WS().success)){
				goto mismatch99;
			}
			if(!(terminal("}").success)){
				goto mismatch99;
			}
			if(!(parse_WS().success)){
				goto mismatch99;
			}
			{//OptionalExpr
				{//Expression
					uint start90 = position;
					if((parse_Binding().assign!(Binding)(bind_binding) && parse_WS().success)){
						clearErrors();
					}else{
						position = start90;
					}
				}
			}
			{//OptionalExpr
				{//Expression
					uint start92 = position;
					if((parse_SubExpression().assign!(SubExpression)(bind_term))){
						clearErrors();
					}else{
						position = start92;
					}
				}
			}
			goto match98;
		mismatch99:
			{/*do nothing*/}
			position = start88;
			goto mismatch97;
		match98:
			clearErrors();
			goto match96;
		}
	match96:
		debug Stdout.formatln("parse_ZeroOrMoreExpr() PASS");
		ResultT!(ZeroOrMoreExpr) passed = ResultT!(ZeroOrMoreExpr)(new ZeroOrMoreExpr(bind_expr,bind_binding,bind_term));
		return passed;
	mismatch97:
		position = start87;
		ResultT!(ZeroOrMoreExpr) failed = ResultT!(ZeroOrMoreExpr)();
		return failed;
	}

	/*
	
Terminal
	= new Terminal(String text,Binding binding)
	::=  String:text  WS [  Binding:binding];

	*/
	public ResultT!(Terminal) parse_Terminal(){
		debug Stdout.formatln("parse_Terminal()");
		uint start93 = position;
		String bind_text;
		Binding bind_binding;
		
		
		{//Expression
			uint start94 = position;
			if(!(parse_String().assign!(String)(bind_text))){
				goto mismatch103;
			}
			if(!(parse_WS().success)){
				goto mismatch103;
			}
			{//OptionalExpr
				{//Expression
					uint start96 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start96;
					}
				}
			}
			goto match102;
		mismatch103:
			setError("Expected String.");
			position = start94;
			goto mismatch101;
		match102:
			clearErrors();
			goto match100;
		}
	match100:
		debug Stdout.formatln("parse_Terminal() PASS");
		ResultT!(Terminal) passed = ResultT!(Terminal)(new Terminal(bind_text,bind_binding));
		return passed;
	mismatch101:
		position = start93;
		ResultT!(Terminal) failed = ResultT!(Terminal)();
		return failed;
	}

	/*
	
Range
	= new Range(String start,String end,Binding binding)
	::=  HexExpr:start  WS [  "-"  WS  HexExpr:end  WS] [  Binding:binding];

	*/
	public ResultT!(Range) parse_Range(){
		debug Stdout.formatln("parse_Range()");
		uint start97 = position;
		String bind_start;
		String bind_end;
		Binding bind_binding;
		
		
		{//Expression
			uint start98 = position;
			if(!(parse_HexExpr().assign!(String)(bind_start))){
				goto mismatch107;
			}
			if(!(parse_WS().success)){
				goto mismatch107;
			}
			{//OptionalExpr
				{//Expression
					uint start100 = position;
					if((terminal("-").success && parse_WS().success && parse_HexExpr().assign!(String)(bind_end) && parse_WS().success)){
						clearErrors();
					}else{
						position = start100;
					}
				}
			}
			{//OptionalExpr
				{//Expression
					uint start102 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start102;
					}
				}
			}
			goto match106;
		mismatch107:
			setError("Expected HexExpr.");
			position = start98;
			goto mismatch105;
		match106:
			clearErrors();
			goto match104;
		}
	match104:
		debug Stdout.formatln("parse_Range() PASS");
		ResultT!(Range) passed = ResultT!(Range)(new Range(bind_start,bind_end,bind_binding));
		return passed;
	mismatch105:
		position = start97;
		ResultT!(Range) failed = ResultT!(Range)();
		return failed;
	}

	/*
	
Regexp
	= new Regexp(String text,Binding binding)
	::= (  "r"  String:text |  "`" {  any}:text "`")  WS [  Binding:binding];

	*/
	public ResultT!(Regexp) parse_Regexp(){
		debug Stdout.formatln("parse_Regexp()");
		uint start103 = position;
		String bind_text;
		Binding bind_binding;
		
		
		{//Expression
			uint start104 = position;
			{//Expression
				uint start105 = position;
				if(terminal("r").success && parse_String().assign!(String)(bind_text)){
					goto match112;
				}
				if(!(terminal("`").success)){
					goto mismatch113;
				}
				{//ZeroOrMoreExpr
					uint start106 = position;
					uint termPos107;
				loop114:
					termPos107 = position;
					if(terminal("`").success){
						goto loopend115;
					}else{
						goto exprStart116;
					}
				exprStart116:
					{//Expression
						uint start108 = position;
						if((parse_any().success)){
							clearErrors();
							goto loop114;
						}else{
							setError("Expected any.");
							position = start108;
							goto loopend115;
						}
					}
				loopend115:
					smartAssign!(String,String)(bind_text,sliceData(start106,termPos107));
					{/*do nothing*/}
				}
				goto match112;
			mismatch113:
				{/*do nothing*/}
				position = start105;
				goto mismatch111;
			match112:
				clearErrors();
				{/*do nothing*/}
			}
			if(!(parse_WS().success)){
				goto mismatch111;
			}
			{//OptionalExpr
				{//Expression
					uint start110 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start110;
					}
				}
			}
			goto match110;
		mismatch111:
			{/*do nothing*/}
			position = start104;
			goto mismatch109;
		match110:
			clearErrors();
			goto match108;
		}
	match108:
		debug Stdout.formatln("parse_Regexp() PASS");
		ResultT!(Regexp) passed = ResultT!(Regexp)(new Regexp(bind_text,bind_binding));
		return passed;
	mismatch109:
		position = start103;
		ResultT!(Regexp) failed = ResultT!(Regexp)();
		return failed;
	}

	/*
	
NegateExpr
	= new Negate(SubExpression expr)
	::=  "!"  WS  SubExpression:expr;

	*/
	public ResultT!(Negate) parse_NegateExpr(){
		debug Stdout.formatln("parse_NegateExpr()");
		uint start111 = position;
		SubExpression bind_expr;
		
		
		{//Expression
			uint start112 = position;
			if((terminal("!").success && parse_WS().success && parse_SubExpression().assign!(SubExpression)(bind_expr))){
				clearErrors();
				goto match117;
			}else{
				position = start112;
				goto mismatch118;
			}
		}
	match117:
		debug Stdout.formatln("parse_NegateExpr() PASS");
		ResultT!(Negate) passed = ResultT!(Negate)(new Negate(bind_expr));
		return passed;
	mismatch118:
		position = start111;
		ResultT!(Negate) failed = ResultT!(Negate)();
		return failed;
	}

	/*
	
TestExpr
	= new Test(SubExpression expr)
	::=  "/"  WS  SubExpression:expr;

	*/
	public ResultT!(Test) parse_TestExpr(){
		debug Stdout.formatln("parse_TestExpr()");
		uint start113 = position;
		SubExpression bind_expr;
		
		
		{//Expression
			uint start114 = position;
			if((terminal("/").success && parse_WS().success && parse_SubExpression().assign!(SubExpression)(bind_expr))){
				clearErrors();
				goto match119;
			}else{
				position = start114;
				goto mismatch120;
			}
		}
	match119:
		debug Stdout.formatln("parse_TestExpr() PASS");
		ResultT!(Test) passed = ResultT!(Test)(new Test(bind_expr));
		return passed;
	mismatch120:
		position = start113;
		ResultT!(Test) failed = ResultT!(Test)();
		return failed;
	}

	/*
	
LiteralExpr
	= new LiteralExpr(String name,Binding binding,ProductionArg[] args)
	::=  "@"  Identifier:name  WS [  "!("  WS  ProductionArg:~args {  WS  ","  WS  ProductionArg:~args} ")"] [  Binding:binding];

	*/
	public ResultT!(LiteralExpr) parse_LiteralExpr(){
		debug Stdout.formatln("parse_LiteralExpr()");
		uint start115 = position;
		String bind_name;
		Binding bind_binding;
		ProductionArg[] bind_args;
		
		
		{//Expression
			uint start116 = position;
			if(!(terminal("@").success)){
				goto mismatch124;
			}
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch124;
			}
			if(!(parse_WS().success)){
				goto mismatch124;
			}
			{//OptionalExpr
				{//Expression
					uint start118 = position;
					if(!(terminal("!(").success)){
						goto mismatch126;
					}
					if(!(parse_WS().success)){
						goto mismatch126;
					}
					if(!(parse_ProductionArg().assignCat!(ProductionArg[])(bind_args))){
						goto mismatch126;
					}
					{//ZeroOrMoreExpr
						uint start119 = position;
						uint termPos120;
					loop127:
						termPos120 = position;
						if(terminal(")").success){
							goto loopend128;
						}else{
							goto exprStart129;
						}
					exprStart129:
						{//Expression
							uint start121 = position;
							if((parse_WS().success && terminal(",").success && parse_WS().success && parse_ProductionArg().assignCat!(ProductionArg[])(bind_args))){
								clearErrors();
								goto loop127;
							}else{
								setError("Expected WS.");
								position = start121;
								goto loopend128;
							}
						}
					loopend128:
						{/*do nothing*/}
					}
					goto match125;
				mismatch126:
					{/*do nothing*/}
					position = start118;
					{/*do nothing*/}
				match125:
					clearErrors();
					{/*do nothing*/}
				}
			}
			{//OptionalExpr
				{//Expression
					uint start123 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start123;
					}
				}
			}
			goto match123;
		mismatch124:
			{/*do nothing*/}
			position = start116;
			goto mismatch122;
		match123:
			clearErrors();
			goto match121;
		}
	match121:
		debug Stdout.formatln("parse_LiteralExpr() PASS");
		ResultT!(LiteralExpr) passed = ResultT!(LiteralExpr)(new LiteralExpr(bind_name,bind_binding,bind_args));
		return passed;
	mismatch122:
		position = start115;
		ResultT!(LiteralExpr) failed = ResultT!(LiteralExpr)();
		return failed;
	}

	/*
	
CustomTerminal
	= new CustomTerminal(String name,Binding binding)
	::=  "&"  Identifier:name  WS [  Binding:binding];

	*/
	public ResultT!(CustomTerminal) parse_CustomTerminal(){
		debug Stdout.formatln("parse_CustomTerminal()");
		uint start124 = position;
		String bind_name;
		Binding bind_binding;
		
		
		{//Expression
			uint start125 = position;
			if(!(terminal("&").success)){
				goto mismatch133;
			}
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch133;
			}
			if(!(parse_WS().success)){
				goto mismatch133;
			}
			{//OptionalExpr
				{//Expression
					uint start127 = position;
					if((parse_Binding().assign!(Binding)(bind_binding))){
						clearErrors();
					}else{
						position = start127;
					}
				}
			}
			goto match132;
		mismatch133:
			{/*do nothing*/}
			position = start125;
			goto mismatch131;
		match132:
			clearErrors();
			goto match130;
		}
	match130:
		debug Stdout.formatln("parse_CustomTerminal() PASS");
		ResultT!(CustomTerminal) passed = ResultT!(CustomTerminal)(new CustomTerminal(bind_name,bind_binding));
		return passed;
	mismatch131:
		position = start124;
		ResultT!(CustomTerminal) failed = ResultT!(CustomTerminal)();
		return failed;
	}

	/*
	
Binding
	= new Binding(bool isConcat,String name)
	::=  ":"  WS [  "~"]:isConcat   WS  Identifier:name;

	*/
	public ResultT!(Binding) parse_Binding(){
		debug Stdout.formatln("parse_Binding()");
		uint start128 = position;
		bool bind_isConcat;
		String bind_name;
		
		
		{//Expression
			uint start129 = position;
			if(!(terminal(":").success)){
				goto mismatch137;
			}
			if(!(parse_WS().success)){
				goto mismatch137;
			}
			{//OptionalExpr
				uint start130 = position;
				{//Expression
					uint start131 = position;
					if((terminal("~").success)){
						clearErrors();
					}else{
						position = start131;
					}
				}
				smartAssign!(bool,String)(bind_isConcat,sliceData(start130,position));
			}
			if(!(parse_WS().success)){
				goto mismatch137;
			}
			if(!(parse_Identifier().assign!(String)(bind_name))){
				goto mismatch137;
			}
			goto match136;
		mismatch137:
			{/*do nothing*/}
			position = start129;
			goto mismatch135;
		match136:
			clearErrors();
			goto match134;
		}
	match134:
		debug Stdout.formatln("parse_Binding() PASS");
		ResultT!(Binding) passed = ResultT!(Binding)(new Binding(bind_isConcat,bind_name));
		return passed;
	mismatch135:
		position = start128;
		ResultT!(Binding) failed = ResultT!(Binding)();
		return failed;
	}

	/*
	
Identifier
	= String value
	::= (  IdentifierStartChar {  IdentifierChar}):value ;

	*/
	public ResultT!(String) parse_Identifier(){
		debug Stdout.formatln("parse_Identifier()");
		uint start132 = position;
		String bind_value;
		
		
		{//Expression
			uint start133 = position;
			{//GroupExpr
				uint start134 = position;
				{//Expression
					uint start135 = position;
					if(!(parse_IdentifierStartChar().success)){
						goto mismatch143;
					}
					{//ZeroOrMoreExpr
						uint termPos137;
					loop144:
						termPos137 = position;
					exprStart146:
						{//Expression
							uint start138 = position;
							if((parse_IdentifierChar().success)){
								clearErrors();
								goto loop144;
							}else{
								setError("Expected IdentifierChar.");
								position = start138;
								goto loopend145;
							}
						}
					loopend145:
						{/*do nothing*/}
					}
					goto match142;
				mismatch143:
					setError("Expected IdentifierStartChar.");
					position = start135;
					goto mismatch141;
				match142:
					clearErrors();
					{/*do nothing*/}
				}
				smartAssign!(String,String)(bind_value,sliceData(start134,position));
			}
			goto match140;
		mismatch141:
			{/*do nothing*/}
			position = start133;
			goto mismatch139;
		match140:
			clearErrors();
			goto match138;
		}
	match138:
		debug Stdout.formatln("parse_Identifier() PASS");
		return ResultT!(String)(bind_value);
	mismatch139:
		position = start132;
		return ResultT!(String)();
	}

	/*
	
IdentifierStartChar
	= String text
	::= (  letter |  "_"):text ;

	*/
	public ResultT!(String) parse_IdentifierStartChar(){
		debug Stdout.formatln("parse_IdentifierStartChar()");
		uint start139 = position;
		String bind_text;
		
		
		{//Expression
			uint start140 = position;
			{//GroupExpr
				uint start141 = position;
				{//Expression
					uint start142 = position;
					if((parse_letter().success) || (terminal("_").success)){
						clearErrors();
					}else{
						setError("Expected letter.");
						position = start142;
						goto mismatch150;
					}
				}
				smartAssign!(String,String)(bind_text,sliceData(start141,position));
			}
			goto match149;
		mismatch150:
			{/*do nothing*/}
			position = start140;
			goto mismatch148;
		match149:
			clearErrors();
			goto match147;
		}
	match147:
		debug Stdout.formatln("parse_IdentifierStartChar() PASS");
		return ResultT!(String)(bind_text);
	mismatch148:
		position = start139;
		return ResultT!(String)();
	}

	/*
	
IdentifierChar
	= String text
	::= (  letter |  digit |  "_" |  "."):text ;

	*/
	public ResultT!(String) parse_IdentifierChar(){
		debug Stdout.formatln("parse_IdentifierChar()");
		uint start143 = position;
		String bind_text;
		
		
		{//Expression
			uint start144 = position;
			{//GroupExpr
				uint start145 = position;
				{//Expression
					uint start146 = position;
					if((parse_letter().success) || (parse_digit().success) || (terminal("_").success) || (terminal(".").success)){
						clearErrors();
					}else{
						setError("Expected letter or digit.");
						position = start146;
						goto mismatch154;
					}
				}
				smartAssign!(String,String)(bind_text,sliceData(start145,position));
			}
			goto match153;
		mismatch154:
			{/*do nothing*/}
			position = start144;
			goto mismatch152;
		match153:
			clearErrors();
			goto match151;
		}
	match151:
		debug Stdout.formatln("parse_IdentifierChar() PASS");
		return ResultT!(String)(bind_text);
	mismatch152:
		position = start143;
		return ResultT!(String)();
	}

	/*
	
String
	= String text
	::= (  "\"" |  "\'"):~delim  {  AnyChar}:text.delim;

	*/
	public ResultT!(String) parse_String(){
		debug Stdout.formatln("parse_String()");
		uint start147 = position;
		String bind_text;
		
		String bind_delim;
		
		{//Expression
			uint start148 = position;
			{//GroupExpr
				uint start149 = position;
				{//Expression
					uint start150 = position;
					if((terminal("\"").success) || (terminal("\'").success)){
						clearErrors();
					}else{
						position = start150;
						goto mismatch158;
					}
				}
				smartAssignCat!(String,String)(bind_delim,sliceData(start149,position));
			}
			{//ZeroOrMoreExpr
				uint start151 = position;
				uint termPos152;
			loop159:
				termPos152 = position;
				if(terminal(convert!(String,String)(bind_delim)).success){
					goto loopend160;
				}else{
					goto exprStart161;
				}
			exprStart161:
				{//Expression
					uint start153 = position;
					if((parse_AnyChar().success)){
						clearErrors();
						goto loop159;
					}else{
						setError("Expected AnyChar.");
						position = start153;
						goto loopend160;
					}
				}
			loopend160:
				smartAssign!(String,String)(bind_text,sliceData(start151,termPos152));
				{/*do nothing*/}
			}
			goto match157;
		mismatch158:
			{/*do nothing*/}
			position = start148;
			goto mismatch156;
		match157:
			clearErrors();
			goto match155;
		}
	match155:
		debug Stdout.formatln("parse_String() PASS");
		return ResultT!(String)(bind_text);
	mismatch156:
		position = start147;
		return ResultT!(String)();
	}

	/*
	
HexExpr
	= String text
	::=  "#" (  hexdigit  hexdigit [  hexdigit  hexdigit [  hexdigit  hexdigit  hexdigit  hexdigit [  hexdigit  hexdigit  hexdigit  hexdigit  hexdigit  hexdigit  hexdigit  hexdigit]]]):text ;

	*/
	public ResultT!(String) parse_HexExpr(){
		debug Stdout.formatln("parse_HexExpr()");
		uint start154 = position;
		String bind_text;
		
		
		{//Expression
			uint start155 = position;
			if(!(terminal("#").success)){
				goto mismatch165;
			}
			{//GroupExpr
				uint start156 = position;
				{//Expression
					uint start157 = position;
					if(!(parse_hexdigit().success)){
						goto mismatch167;
					}
					if(!(parse_hexdigit().success)){
						goto mismatch167;
					}
					{//OptionalExpr
						{//Expression
							uint start159 = position;
							if(!(parse_hexdigit().success)){
								goto mismatch169;
							}
							if(!(parse_hexdigit().success)){
								goto mismatch169;
							}
							{//OptionalExpr
								{//Expression
									uint start161 = position;
									if(!(parse_hexdigit().success)){
										goto mismatch171;
									}
									if(!(parse_hexdigit().success)){
										goto mismatch171;
									}
									if(!(parse_hexdigit().success)){
										goto mismatch171;
									}
									if(!(parse_hexdigit().success)){
										goto mismatch171;
									}
									{//OptionalExpr
										{//Expression
											uint start163 = position;
											if((parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success && parse_hexdigit().success)){
												clearErrors();
											}else{
												position = start163;
											}
										}
									}
									goto match170;
								mismatch171:
									{/*do nothing*/}
									position = start161;
									{/*do nothing*/}
								match170:
									clearErrors();
									{/*do nothing*/}
								}
							}
							goto match168;
						mismatch169:
							{/*do nothing*/}
							position = start159;
							{/*do nothing*/}
						match168:
							clearErrors();
							{/*do nothing*/}
						}
					}
					goto match166;
				mismatch167:
					setError("Expected hexdigit.");
					position = start157;
					goto mismatch165;
				match166:
					clearErrors();
					{/*do nothing*/}
				}
				smartAssign!(String,String)(bind_text,sliceData(start156,position));
			}
			goto match164;
		mismatch165:
			{/*do nothing*/}
			position = start155;
			goto mismatch163;
		match164:
			clearErrors();
			goto match162;
		}
	match162:
		debug Stdout.formatln("parse_HexExpr() PASS");
		return ResultT!(String)(bind_text);
	mismatch163:
		position = start154;
		return ResultT!(String)();
	}

	/*
	
AnyChar
	= String value
	::= [  "\\":~value]  any:~value;

	*/
	public ResultT!(String) parse_AnyChar(){
		debug Stdout.formatln("parse_AnyChar()");
		uint start164 = position;
		String bind_value;
		
		
		{//Expression
			uint start165 = position;
			{//OptionalExpr
				{//Expression
					uint start167 = position;
					if((terminal("\\").assignCat!(String)(bind_value))){
						clearErrors();
					}else{
						position = start167;
					}
				}
			}
			if(!(parse_any().assignCat!(String)(bind_value))){
				goto mismatch175;
			}
			goto match174;
		mismatch175:
			{/*do nothing*/}
			position = start165;
			goto mismatch173;
		match174:
			clearErrors();
			goto match172;
		}
	match172:
		debug Stdout.formatln("parse_AnyChar() PASS");
		return ResultT!(String)(bind_value);
	mismatch173:
		position = start164;
		return ResultT!(String)();
	}

	/*
	
Comment
	= new Comment(String text)
	::=  PoundComment:text |  SlashSlashComment:text |  SlashStarComment:text;

	*/
	public ResultT!(Comment) parse_Comment(){
		debug Stdout.formatln("parse_Comment()");
		uint start168 = position;
		String bind_text;
		
		
		{//Expression
			uint start169 = position;
			if((parse_PoundComment().assign!(String)(bind_text)) || (parse_SlashSlashComment().assign!(String)(bind_text)) || (parse_SlashStarComment().assign!(String)(bind_text))){
				clearErrors();
				goto match176;
			}else{
				setError("Expected PoundComment, SlashSlashComment or SlashStarComment.");
				position = start169;
				goto mismatch177;
			}
		}
	match176:
		debug Stdout.formatln("parse_Comment() PASS");
		ResultT!(Comment) passed = ResultT!(Comment)(new Comment(bind_text));
		return passed;
	mismatch177:
		position = start168;
		ResultT!(Comment) failed = ResultT!(Comment)();
		return failed;
	}

	/*
	
PoundComment
	= String text
	::=  "#" {  any}:text eol;

	*/
	public ResultT!(String) parse_PoundComment(){
		debug Stdout.formatln("parse_PoundComment()");
		uint start170 = position;
		String bind_text;
		
		
		{//Expression
			uint start171 = position;
			if(!(terminal("#").success)){
				goto mismatch181;
			}
			{//ZeroOrMoreExpr
				uint start172 = position;
				uint termPos173;
			loop182:
				termPos173 = position;
				if(parse_eol().success){
					goto loopend183;
				}else{
					goto exprStart184;
				}
			exprStart184:
				{//Expression
					uint start174 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop182;
					}else{
						setError("Expected any.");
						position = start174;
						goto loopend183;
					}
				}
			loopend183:
				smartAssign!(String,String)(bind_text,sliceData(start172,termPos173));
				{/*do nothing*/}
			}
			goto match180;
		mismatch181:
			{/*do nothing*/}
			position = start171;
			goto mismatch179;
		match180:
			clearErrors();
			goto match178;
		}
	match178:
		debug Stdout.formatln("parse_PoundComment() PASS");
		return ResultT!(String)(bind_text);
	mismatch179:
		position = start170;
		return ResultT!(String)();
	}

	/*
	
SlashSlashComment
	= String text
	::=  "\x2F\x2F" {  any}:text eol;

	*/
	public ResultT!(String) parse_SlashSlashComment(){
		debug Stdout.formatln("parse_SlashSlashComment()");
		uint start175 = position;
		String bind_text;
		
		
		{//Expression
			uint start176 = position;
			if(!(terminal("\x2F\x2F").success)){
				goto mismatch188;
			}
			{//ZeroOrMoreExpr
				uint start177 = position;
				uint termPos178;
			loop189:
				termPos178 = position;
				if(parse_eol().success){
					goto loopend190;
				}else{
					goto exprStart191;
				}
			exprStart191:
				{//Expression
					uint start179 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop189;
					}else{
						setError("Expected any.");
						position = start179;
						goto loopend190;
					}
				}
			loopend190:
				smartAssign!(String,String)(bind_text,sliceData(start177,termPos178));
				{/*do nothing*/}
			}
			goto match187;
		mismatch188:
			{/*do nothing*/}
			position = start176;
			goto mismatch186;
		match187:
			clearErrors();
			goto match185;
		}
	match185:
		debug Stdout.formatln("parse_SlashSlashComment() PASS");
		return ResultT!(String)(bind_text);
	mismatch186:
		position = start175;
		return ResultT!(String)();
	}

	/*
	
SlashStarComment
	= String text
	::=  "\x2F\x2A" {  any}:text "\x2A\x2F";

	*/
	public ResultT!(String) parse_SlashStarComment(){
		debug Stdout.formatln("parse_SlashStarComment()");
		uint start180 = position;
		String bind_text;
		
		
		{//Expression
			uint start181 = position;
			if(!(terminal("\x2F\x2A").success)){
				goto mismatch195;
			}
			{//ZeroOrMoreExpr
				uint start182 = position;
				uint termPos183;
			loop196:
				termPos183 = position;
				if(terminal("\x2A\x2F").success){
					goto loopend197;
				}else{
					goto exprStart198;
				}
			exprStart198:
				{//Expression
					uint start184 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop196;
					}else{
						setError("Expected any.");
						position = start184;
						goto loopend197;
					}
				}
			loopend197:
				smartAssign!(String,String)(bind_text,sliceData(start182,termPos183));
				{/*do nothing*/}
			}
			goto match194;
		mismatch195:
			{/*do nothing*/}
			position = start181;
			goto mismatch193;
		match194:
			clearErrors();
			goto match192;
		}
	match192:
		debug Stdout.formatln("parse_SlashStarComment() PASS");
		return ResultT!(String)(bind_text);
	mismatch193:
		position = start180;
		return ResultT!(String)();
	}

	/*
	
Directive
	= Directive dir
	::=  "." (  ImportDirective:~dir |  BaseClassDirective:~dir |  ClassnameDirective:~dir |  DefineDirective:~dir |  IncludeDirective:~dir |  AliasDirective:~dir |  ModuleDirective:~dir |  CodeDirective:~dir |  TypelibDirective:~dir |  ParseTypeDirective:~dir |  BoilerplateDirective:~dir |  HeaderDirective:~dir |  UTFDirective:~dir);

	*/
	public ResultT!(Directive) parse_Directive(){
		debug Stdout.formatln("parse_Directive()");
		uint start185 = position;
		Directive bind_dir;
		
		
		{//Expression
			uint start186 = position;
			if(!(terminal(".").success)){
				goto mismatch202;
			}
			{//Expression
				uint start187 = position;
				if((parse_ImportDirective().assignCat!(Directive)(bind_dir)) || (parse_BaseClassDirective().assignCat!(Directive)(bind_dir)) || (parse_ClassnameDirective().assignCat!(Directive)(bind_dir)) || (parse_DefineDirective().assignCat!(Directive)(bind_dir)) || (parse_IncludeDirective().assignCat!(Directive)(bind_dir)) || (parse_AliasDirective().assignCat!(Directive)(bind_dir)) || (parse_ModuleDirective().assignCat!(Directive)(bind_dir)) || (parse_CodeDirective().assignCat!(Directive)(bind_dir)) || (parse_TypelibDirective().assignCat!(Directive)(bind_dir)) || (parse_ParseTypeDirective().assignCat!(Directive)(bind_dir)) || (parse_BoilerplateDirective().assignCat!(Directive)(bind_dir)) || (parse_HeaderDirective().assignCat!(Directive)(bind_dir)) || (parse_UTFDirective().assignCat!(Directive)(bind_dir))){
					clearErrors();
				}else{
					setError("Expected ImportDirective, BaseClassDirective, ClassnameDirective, DefineDirective, IncludeDirective, AliasDirective, ModuleDirective, CodeDirective, TypelibDirective, ParseTypeDirective, BoilerplateDirective, HeaderDirective or UTFDirective.");
					position = start187;
					goto mismatch202;
				}
			}
			goto match201;
		mismatch202:
			{/*do nothing*/}
			position = start186;
			goto mismatch200;
		match201:
			clearErrors();
			goto match199;
		}
	match199:
		debug Stdout.formatln("parse_Directive() PASS");
		return ResultT!(Directive)(bind_dir);
	mismatch200:
		position = start185;
		return ResultT!(Directive)();
	}

	/*
	
ImportDirective
	= new ImportDirective(String imp)
	::=  "import"  WS  "("  WS  DirectiveArg:imp  WS  ")"  WS  ";";

	*/
	public ResultT!(ImportDirective) parse_ImportDirective(){
		debug Stdout.formatln("parse_ImportDirective()");
		uint start188 = position;
		String bind_imp;
		
		
		{//Expression
			uint start189 = position;
			if((terminal("import").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_imp) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match203;
			}else{
				position = start189;
				goto mismatch204;
			}
		}
	match203:
		debug Stdout.formatln("parse_ImportDirective() PASS");
		ResultT!(ImportDirective) passed = ResultT!(ImportDirective)(new ImportDirective(bind_imp));
		return passed;
	mismatch204:
		position = start188;
		ResultT!(ImportDirective) failed = ResultT!(ImportDirective)();
		return failed;
	}

	/*
	
BaseClassDirective
	= new BaseClassDirective(String name)
	::=  "baseclass"  WS  "("  WS  DirectiveArg:name  WS  ")"  WS  ";";

	*/
	public ResultT!(BaseClassDirective) parse_BaseClassDirective(){
		debug Stdout.formatln("parse_BaseClassDirective()");
		uint start190 = position;
		String bind_name;
		
		
		{//Expression
			uint start191 = position;
			if((terminal("baseclass").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_name) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match205;
			}else{
				position = start191;
				goto mismatch206;
			}
		}
	match205:
		debug Stdout.formatln("parse_BaseClassDirective() PASS");
		ResultT!(BaseClassDirective) passed = ResultT!(BaseClassDirective)(new BaseClassDirective(bind_name));
		return passed;
	mismatch206:
		position = start190;
		ResultT!(BaseClassDirective) failed = ResultT!(BaseClassDirective)();
		return failed;
	}

	/*
	
ClassnameDirective
	= new ClassnameDirective(String name)
	::=  "classname"  WS  "("  WS  DirectiveArg:name  WS  ")"  WS  ";";

	*/
	public ResultT!(ClassnameDirective) parse_ClassnameDirective(){
		debug Stdout.formatln("parse_ClassnameDirective()");
		uint start192 = position;
		String bind_name;
		
		
		{//Expression
			uint start193 = position;
			if((terminal("classname").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_name) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match207;
			}else{
				position = start193;
				goto mismatch208;
			}
		}
	match207:
		debug Stdout.formatln("parse_ClassnameDirective() PASS");
		ResultT!(ClassnameDirective) passed = ResultT!(ClassnameDirective)(new ClassnameDirective(bind_name));
		return passed;
	mismatch208:
		position = start192;
		ResultT!(ClassnameDirective) failed = ResultT!(ClassnameDirective)();
		return failed;
	}

	/*
	
DefineDirective
	= new DefineDirective(String returnType,String name,bool isTerminal,String description)
	::=  "define"  WS  "("  WS  DirectiveArg:returnType  WS  ","  WS  DirectiveArg:name  WS  ","  WS  DirectiveArg:isTerminal  WS [  ","  WS  DirectiveArg:description  WS]  ")"  WS  ";";

	*/
	public ResultT!(DefineDirective) parse_DefineDirective(){
		debug Stdout.formatln("parse_DefineDirective()");
		uint start194 = position;
		String bind_returnType;
		String bind_name;
		bool bind_isTerminal;
		String bind_description;
		
		
		{//Expression
			uint start195 = position;
			if(!(terminal("define").success)){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(terminal("(").success)){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(parse_DirectiveArg().assign!(String)(bind_returnType))){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(terminal(",").success)){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(parse_DirectiveArg().assign!(String)(bind_name))){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(terminal(",").success)){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(parse_DirectiveArg().assign!(bool)(bind_isTerminal))){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			{//OptionalExpr
				{//Expression
					uint start197 = position;
					if((terminal(",").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_description) && parse_WS().success)){
						clearErrors();
					}else{
						position = start197;
					}
				}
			}
			if(!(terminal(")").success)){
				goto mismatch212;
			}
			if(!(parse_WS().success)){
				goto mismatch212;
			}
			if(!(terminal(";").success)){
				goto mismatch212;
			}
			goto match211;
		mismatch212:
			{/*do nothing*/}
			position = start195;
			goto mismatch210;
		match211:
			clearErrors();
			goto match209;
		}
	match209:
		debug Stdout.formatln("parse_DefineDirective() PASS");
		ResultT!(DefineDirective) passed = ResultT!(DefineDirective)(new DefineDirective(bind_returnType,bind_name,bind_isTerminal,bind_description));
		return passed;
	mismatch210:
		position = start194;
		ResultT!(DefineDirective) failed = ResultT!(DefineDirective)();
		return failed;
	}

	/*
	
IncludeDirective
	= new IncludeDirective(String filename)
	::=  "include"  WS  "("  WS  String:filename  WS  ")"  WS  ";";

	*/
	public ResultT!(IncludeDirective) parse_IncludeDirective(){
		debug Stdout.formatln("parse_IncludeDirective()");
		uint start198 = position;
		String bind_filename;
		
		
		{//Expression
			uint start199 = position;
			if((terminal("include").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_String().assign!(String)(bind_filename) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match213;
			}else{
				position = start199;
				goto mismatch214;
			}
		}
	match213:
		debug Stdout.formatln("parse_IncludeDirective() PASS");
		ResultT!(IncludeDirective) passed = ResultT!(IncludeDirective)(new IncludeDirective(bind_filename));
		return passed;
	mismatch214:
		position = start198;
		ResultT!(IncludeDirective) failed = ResultT!(IncludeDirective)();
		return failed;
	}

	/*
	
AliasDirective
	= new AliasDirective(String rule,String ruleAlias)
	::=  "alias"  WS  "("  WS  DirectiveArg:rule  WS  ","  WS  DirectiveArg:ruleAlias  WS  ")"  WS  ";";

	*/
	public ResultT!(AliasDirective) parse_AliasDirective(){
		debug Stdout.formatln("parse_AliasDirective()");
		uint start200 = position;
		String bind_rule;
		String bind_ruleAlias;
		
		
		{//Expression
			uint start201 = position;
			if((terminal("alias").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_rule) && parse_WS().success && terminal(",").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_ruleAlias) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match215;
			}else{
				position = start201;
				goto mismatch216;
			}
		}
	match215:
		debug Stdout.formatln("parse_AliasDirective() PASS");
		ResultT!(AliasDirective) passed = ResultT!(AliasDirective)(new AliasDirective(bind_rule,bind_ruleAlias));
		return passed;
	mismatch216:
		position = start200;
		ResultT!(AliasDirective) failed = ResultT!(AliasDirective)();
		return failed;
	}

	/*
	
ModuleDirective
	= new ModuleDirective(String moduleName)
	::=  "module"  WS  "("  WS  DirectiveArg:moduleName  WS  ")"  WS  ";";

	*/
	public ResultT!(ModuleDirective) parse_ModuleDirective(){
		debug Stdout.formatln("parse_ModuleDirective()");
		uint start202 = position;
		String bind_moduleName;
		
		
		{//Expression
			uint start203 = position;
			if((terminal("module").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_moduleName) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match217;
			}else{
				position = start203;
				goto mismatch218;
			}
		}
	match217:
		debug Stdout.formatln("parse_ModuleDirective() PASS");
		ResultT!(ModuleDirective) passed = ResultT!(ModuleDirective)(new ModuleDirective(bind_moduleName));
		return passed;
	mismatch218:
		position = start202;
		ResultT!(ModuleDirective) failed = ResultT!(ModuleDirective)();
		return failed;
	}

	/*
	
CodeDirective
	= new CodeDirective(String code)
	::=  "code"  WS  "{{{" {  any}:code "}}}";

	*/
	public ResultT!(CodeDirective) parse_CodeDirective(){
		debug Stdout.formatln("parse_CodeDirective()");
		uint start204 = position;
		String bind_code;
		
		
		{//Expression
			uint start205 = position;
			if(!(terminal("code").success)){
				goto mismatch222;
			}
			if(!(parse_WS().success)){
				goto mismatch222;
			}
			if(!(terminal("{{{").success)){
				goto mismatch222;
			}
			{//ZeroOrMoreExpr
				uint start206 = position;
				uint termPos207;
			loop223:
				termPos207 = position;
				if(terminal("}}}").success){
					goto loopend224;
				}else{
					goto exprStart225;
				}
			exprStart225:
				{//Expression
					uint start208 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop223;
					}else{
						setError("Expected any.");
						position = start208;
						goto loopend224;
					}
				}
			loopend224:
				smartAssign!(String,String)(bind_code,sliceData(start206,termPos207));
				{/*do nothing*/}
			}
			goto match221;
		mismatch222:
			{/*do nothing*/}
			position = start205;
			goto mismatch220;
		match221:
			clearErrors();
			goto match219;
		}
	match219:
		debug Stdout.formatln("parse_CodeDirective() PASS");
		ResultT!(CodeDirective) passed = ResultT!(CodeDirective)(new CodeDirective(bind_code));
		return passed;
	mismatch220:
		position = start204;
		ResultT!(CodeDirective) failed = ResultT!(CodeDirective)();
		return failed;
	}

	/*
	
TypelibDirective
	= new TypelibDirective(String importName)
	::=  "typelib"  WS  "("  WS  DirectiveArg:importName  WS  ")"  WS  ";";

	*/
	public ResultT!(TypelibDirective) parse_TypelibDirective(){
		debug Stdout.formatln("parse_TypelibDirective()");
		uint start209 = position;
		String bind_importName;
		
		
		{//Expression
			uint start210 = position;
			if((terminal("typelib").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_importName) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match226;
			}else{
				position = start210;
				goto mismatch227;
			}
		}
	match226:
		debug Stdout.formatln("parse_TypelibDirective() PASS");
		ResultT!(TypelibDirective) passed = ResultT!(TypelibDirective)(new TypelibDirective(bind_importName));
		return passed;
	mismatch227:
		position = start209;
		ResultT!(TypelibDirective) failed = ResultT!(TypelibDirective)();
		return failed;
	}

	/*
	
ParseTypeDirective
	= new ParseTypeDirective(String typeName)
	::=  "parsetype"  WS  "("  WS  DirectiveArg:typeName  WS  ")"  WS  ";";

	*/
	public ResultT!(ParseTypeDirective) parse_ParseTypeDirective(){
		debug Stdout.formatln("parse_ParseTypeDirective()");
		uint start211 = position;
		String bind_typeName;
		
		
		{//Expression
			uint start212 = position;
			if((terminal("parsetype").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_typeName) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match228;
			}else{
				position = start212;
				goto mismatch229;
			}
		}
	match228:
		debug Stdout.formatln("parse_ParseTypeDirective() PASS");
		ResultT!(ParseTypeDirective) passed = ResultT!(ParseTypeDirective)(new ParseTypeDirective(bind_typeName));
		return passed;
	mismatch229:
		position = start211;
		ResultT!(ParseTypeDirective) failed = ResultT!(ParseTypeDirective)();
		return failed;
	}

	/*
	
BoilerplateDirective
	= new BoilerplateDirective(String code)
	::=  "boilerplate"  WS  "{{{" {  any}:code "}}}";

	*/
	public ResultT!(BoilerplateDirective) parse_BoilerplateDirective(){
		debug Stdout.formatln("parse_BoilerplateDirective()");
		uint start213 = position;
		String bind_code;
		
		
		{//Expression
			uint start214 = position;
			if(!(terminal("boilerplate").success)){
				goto mismatch233;
			}
			if(!(parse_WS().success)){
				goto mismatch233;
			}
			if(!(terminal("{{{").success)){
				goto mismatch233;
			}
			{//ZeroOrMoreExpr
				uint start215 = position;
				uint termPos216;
			loop234:
				termPos216 = position;
				if(terminal("}}}").success){
					goto loopend235;
				}else{
					goto exprStart236;
				}
			exprStart236:
				{//Expression
					uint start217 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop234;
					}else{
						setError("Expected any.");
						position = start217;
						goto loopend235;
					}
				}
			loopend235:
				smartAssign!(String,String)(bind_code,sliceData(start215,termPos216));
				{/*do nothing*/}
			}
			goto match232;
		mismatch233:
			{/*do nothing*/}
			position = start214;
			goto mismatch231;
		match232:
			clearErrors();
			goto match230;
		}
	match230:
		debug Stdout.formatln("parse_BoilerplateDirective() PASS");
		ResultT!(BoilerplateDirective) passed = ResultT!(BoilerplateDirective)(new BoilerplateDirective(bind_code));
		return passed;
	mismatch231:
		position = start213;
		ResultT!(BoilerplateDirective) failed = ResultT!(BoilerplateDirective)();
		return failed;
	}

	/*
	
HeaderDirective
	= new HeaderDirective(String code)
	::=  "header"  WS  "{{{" {  any}:code "}}}";

	*/
	public ResultT!(HeaderDirective) parse_HeaderDirective(){
		debug Stdout.formatln("parse_HeaderDirective()");
		uint start218 = position;
		String bind_code;
		
		
		{//Expression
			uint start219 = position;
			if(!(terminal("header").success)){
				goto mismatch240;
			}
			if(!(parse_WS().success)){
				goto mismatch240;
			}
			if(!(terminal("{{{").success)){
				goto mismatch240;
			}
			{//ZeroOrMoreExpr
				uint start220 = position;
				uint termPos221;
			loop241:
				termPos221 = position;
				if(terminal("}}}").success){
					goto loopend242;
				}else{
					goto exprStart243;
				}
			exprStart243:
				{//Expression
					uint start222 = position;
					if((parse_any().success)){
						clearErrors();
						goto loop241;
					}else{
						setError("Expected any.");
						position = start222;
						goto loopend242;
					}
				}
			loopend242:
				smartAssign!(String,String)(bind_code,sliceData(start220,termPos221));
				{/*do nothing*/}
			}
			goto match239;
		mismatch240:
			{/*do nothing*/}
			position = start219;
			goto mismatch238;
		match239:
			clearErrors();
			goto match237;
		}
	match237:
		debug Stdout.formatln("parse_HeaderDirective() PASS");
		ResultT!(HeaderDirective) passed = ResultT!(HeaderDirective)(new HeaderDirective(bind_code));
		return passed;
	mismatch238:
		position = start218;
		ResultT!(HeaderDirective) failed = ResultT!(HeaderDirective)();
		return failed;
	}

	/*
	
UTFDirective
	= new UTFDirective(String value)
	::=  "utf"  WS  "("  WS  DirectiveArg:value  WS  ")"  WS  ";";

	*/
	public ResultT!(UTFDirective) parse_UTFDirective(){
		debug Stdout.formatln("parse_UTFDirective()");
		uint start223 = position;
		String bind_value;
		
		
		{//Expression
			uint start224 = position;
			if((terminal("utf").success && parse_WS().success && terminal("(").success && parse_WS().success && parse_DirectiveArg().assign!(String)(bind_value) && parse_WS().success && terminal(")").success && parse_WS().success && terminal(";").success)){
				clearErrors();
				goto match244;
			}else{
				position = start224;
				goto mismatch245;
			}
		}
	match244:
		debug Stdout.formatln("parse_UTFDirective() PASS");
		ResultT!(UTFDirective) passed = ResultT!(UTFDirective)(new UTFDirective(bind_value));
		return passed;
	mismatch245:
		position = start223;
		ResultT!(UTFDirective) failed = ResultT!(UTFDirective)();
		return failed;
	}

	/*
	
DirectiveArg
	= String arg
	::=  Identifier:arg |  String:arg;

	*/
	public ResultT!(String) parse_DirectiveArg(){
		debug Stdout.formatln("parse_DirectiveArg()");
		uint start225 = position;
		String bind_arg;
		
		
		{//Expression
			uint start226 = position;
			if((parse_Identifier().assign!(String)(bind_arg)) || (parse_String().assign!(String)(bind_arg))){
				clearErrors();
				goto match246;
			}else{
				setError("Expected Identifier or String.");
				position = start226;
				goto mismatch247;
			}
		}
	match246:
		debug Stdout.formatln("parse_DirectiveArg() PASS");
		return ResultT!(String)(bind_arg);
	mismatch247:
		position = start225;
		return ResultT!(String)();
	}

}
